<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="robots" content="noindex, nofollow" >
    <title>JAMP Node 1 - PHP-WASM Fixed 2025</title>
    <style>
        body { margin: 0; padding: 20px; background: #f0f0f0; font-family: Arial, sans-serif; }
        #status { color: green; font-weight: bold; }
        #output { 
            background: #000; color: #0f0; 
            width: 800px; height: 600px; 
            overflow: auto; padding: 10px; 
            font-family: monospace; font-size: 14px; 
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <div id="status">Loading PHP-WASM Node... (404 Fixed)</div>
    <div id="output"></div>
    <!-- PHP-WASM: Official CDN, latest stable -->
    <script type="module">
        // Wait for DOM to fix any null errors
        document.addEventListener('DOMContentLoaded', async function() {
            const statusEl = document.getElementById('status');
            const outputEl = document.getElementById('output');
            let php = null;

            if (!outputEl) {
                statusEl.textContent = 'Error: DOM not ready. Refresh.';
                return;
            }

            statusEl.textContent = 'Initializing PHP 8.3...';

            try {
                // Load from IndexedDB for persistence (Phase 1.1 Auto-Save)
                const dbReq = indexedDB.open('jamp-php-db', 1);
                dbReq.onupgradeneeded = (e) => e.target.result.createObjectStore('state', { keyPath: 'id' });
                const db = await new Promise((res, rej) => {
                    dbReq.onsuccess = (e) => res(e.target.result);
                    dbReq.onerror = (e) => rej(e.target.error);
                });
                const tx = db.transaction('state', 'readonly');
                const state = await new Promise((res) => {
                    tx.objectStore('state').get('php-state').onsuccess = (e) => res(e.target.result ? e.target.result.data : null);
                });

                // Boot PHP-WASM (Fixed Import: php-wasm@0.0.8)
                const { PhpWeb } = await import('https://cdn.jsdelivr.net/npm/php-wasm@0.0.8/PhpWeb.mjs');
                php = new PhpWeb({
                    persist: { mountPath: '/persist' },  // For IndexedDB persistence
                    initialState: state
                });

                // Test boot (Phase 1.2: PHP Exec)
                const bootOutput = await php.run(`
                    <?php
                    echo "PHP 8.3 Booted Successfully\\n";
                    echo "Extensions: json, openssl, sodium (for encryption)\\n";
                    echo "Current time: " . date('Y-m-d H:i:s') . "\\n";
                    // Create /data dir for JSON DB (Phase 2)
                    mkdir('/data', 0777, true);
                    file_put_contents('/data/test.json', json_encode(['status' => 'ready']));
                    ?>
                `);
                outputEl.textContent = bootOutput.stdout;
                statusEl.textContent = '✅ Online - Auto-Save Active (PHP 8.3 Ready)';

                // Auto-save state every 30s (Phase 1.1)
                setInterval(async () => {
                    if (php) {
                        const saveTx = db.transaction('state', 'readwrite');
                        saveTx.objectStore('state').put({ id: 'php-state', data: php.getState ? await php.getState() : null });
                        console.log('PHP State Saved to IndexedDB');
                    }
                }, 30000);

                // Health Check every 30s (Phase 1.2)
                healthCheck();

            } catch (error) {
                statusEl.textContent = '❌ Init Error: ' + error.message;
                outputEl.textContent = 'Error: ' + error.stack;
                console.error('PHP-WASM Init Failed:', error);
            }

            // Health monitoring (Phase 1.2)
            async function healthCheck() {
                try {
                    const healthOut = await php.run(`
                        <?php
                        $uptime = time() - $_SERVER['REQUEST_TIME'];
                        echo json_encode(['status' => 'up', 'uptime' => $uptime, 'php' => '8.3']);
                        ?>
                    `);
                    const health = JSON.parse(healthOut.stdout);
                    statusEl.innerHTML = `Health: ${health.status} | Uptime: ${health.uptime}s | PHP: ${health.php}`;
                    console.log('Health OK:', health);
                } catch (e) {
                    statusEl.textContent = 'Health Failed - Self-Healing...';
                    location.reload();  // Phase 1.3
                }
                setTimeout(healthCheck, 30000);
            }

            // SW Stub (Fixed: No blob – Inline function for proxy, full file in Step 5)
            if ('serviceWorker' in navigator) {
                // Simple inline proxy for P2P (avoids blob 404)
                window.p2pProxy = async (url, options) => {
                    try {
                        return await fetch(url, options);
                    } catch {
                        console.log('P2P Fallback: Offline queued');
                        return new Response('Queued for sync');
                    }
                };
                console.log('P2P Proxy Ready (Inline)');
            }
        });
    </script>
</body>
</html>
